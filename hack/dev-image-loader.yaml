apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: kuberhealthy-image-loader
  namespace: kuberhealthy
  labels:
    app: kuberhealthy-image-loader
spec:
  selector:
    matchLabels:
      app: kuberhealthy-image-loader
  updateStrategy:
    type: RollingUpdate
  template:
    metadata:
      labels:
        app: kuberhealthy-image-loader
    spec:
      # Run on all nodes, including control-plane nodes
      tolerations:
        - key: node-role.kubernetes.io/master
          effect: NoSchedule
        - key: node-role.kubernetes.io/control-plane
          effect: NoSchedule
      hostNetwork: false
      securityContext: {}
      containers:
        - name: loader
          image: alpine:3.20
          imagePullPolicy: IfNotPresent
          securityContext:
            privileged: true
          env:
            - name: IMAGE_TAR_URL
              value: "http://REPLACE_WITH_LAPTOP_IP:7777/kuberhealthy-localdev.tar"
            - name: IMAGE_REF
              value: "docker.io/kuberhealthy/kuberhealthy:localdev"
          volumeMounts:
            # Common containerd socket paths
            - name: containerd-run
              mountPath: /run/containerd
            - name: containerd-varrun
              mountPath: /var/run/containerd
            # Docker socket (for older clusters)
            - name: dockersock
              mountPath: /var/run/docker.sock
          command: ["/bin/sh","-c"]
          args:
            - |
              set -euo pipefail
              echo "==> Installing tools (curl, ctr, crictl, docker-cli)"
              apk add --no-cache curl containerd-ctr cri-tools docker-cli >/dev/null

              echo "==> Downloading image tar from: ${IMAGE_TAR_URL}"
              curl -fsSL "${IMAGE_TAR_URL}" -o /tmp/image.tar
              ls -lh /tmp/image.tar

              # Prefer containerd if its socket is present
              if [ -S /run/containerd/containerd.sock ] || [ -S /var/run/containerd/containerd.sock ]; then
                SOCK=""
                if [ -S /run/containerd/containerd.sock ]; then
                  SOCK=/run/containerd/containerd.sock
                else
                  SOCK=/var/run/containerd/containerd.sock
                fi
                echo "==> Detected containerd at $SOCK"
                echo "==> Importing image into containerd (namespace k8s.io)"
                ctr -a "$SOCK" -n k8s.io images import /tmp/image.tar
                echo "==> Verifying image presence"
                ctr -a "$SOCK" -n k8s.io images ls | grep -F "${IMAGE_REF}" || {
                  echo "!! Image ${IMAGE_REF} not found after import" >&2; exit 1; }
                echo "==> Done; keeping pod running to show success"
                sleep 3600

              # Fallback: Docker (legacy runtimes)
              elif [ -S /var/run/docker.sock ]; then
                echo "==> Detected Docker at /var/run/docker.sock"
                DOCKER_HOST=unix:///var/run/docker.sock docker load -i /tmp/image.tar
                echo "==> Verifying image presence"
                DOCKER_HOST=unix:///var/run/docker.sock docker images | grep -F "${IMAGE_REF%:*}" || {
                  echo "!! Image ${IMAGE_REF} not found after docker load" >&2; exit 1; }
                echo "==> Done; keeping pod running to show success"
                sleep 3600

              else
                echo "!! No supported container runtime socket found (containerd or docker)" >&2
                echo "   If your cluster uses CRI-O, prefer the temporary local registry workflow."
                exit 1
              fi
      restartPolicy: Always
      volumes:
        - name: containerd-run
          hostPath:
            path: /run/containerd
            type: DirectoryOrCreate
        - name: containerd-varrun
          hostPath:
            path: /var/run/containerd
            type: DirectoryOrCreate
        - name: dockersock
          hostPath:
            path: /var/run/docker.sock
            type: Socket

